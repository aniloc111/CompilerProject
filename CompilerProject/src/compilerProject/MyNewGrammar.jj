/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";
  LOOKAHEAD = 30000;
  FORCE_LA_CHECK = true;  static = true;}PARSER_BEGIN(EG1)package compilerProject;

public class EG1{  public static void main(String args []) throws ParseException  {    EG1 parser = new EG1(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("[1] Enter an expression like \"1+(2+3)*4;\" :");      try      {        switch (EG1.root())        {          case 0 :           System.out.println("OK.");          break;          case 1 :           System.out.println("Goodbye.");          break;          default :           break;        }      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        EG1.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(EG1)SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
//| "#..*?.#"
// (~(".#"))*
|"(?:#.(?:[^*]|(?:\\*+[^*/]))*.#)"
}

TOKEN :
{
	< OPENCOM 	: "#." >
|   < CLOSECOM	: ".#" >
}

TOKEN : /* mdas OPERATORS */
{
  < ADD : "+" >
| < SUB : "-" >
| < MUL : "*" >
| < DIV : "/" >
| < MOD : "%" >
| < EXP : "^" >
| < EQU : "=" >
}

TOKEN : /* logical OPERATORS */
{
  < AND : "&&" >
| < OR : "||" >
| < NOT : "!" > 
}

TOKEN :
{
   <NUMBER: (<DIGIT>)+>
|  <LOGIC_CONSTANT: "true" | "false">
|  <#DIGIT: ["0"-"9"]>
}

TOKEN : /* relational OPERATORS*/
{
  < GREATERTHAN 			: ">" >
| < LESSERTHAN				: "<" >
| < LESSERTHANEQUAL			: "<=" >
| < GREATERTHANEQUAL		: ">=" >
| < EQUAL					: "==" >
| < NOTEQUAL				: "!=" >  
}

//RESERVED WORDS
TOKEN : {
   <IF: "if">
|  <THEN: "then">
|  <FOR: "for" >
|  <ELSE: "else">
|  <INPUT: "input">
|  <PRINT: "print">
}

TOKEN :
{
	< DELIM : ";" >
| 	< OPENPAR  : "(" >
| 	< CLOSEPAR : ")" >
}

//IDENTIFIER TOKEN
TOKEN : {
  <VARIABLE: (<LETTER >)+>
| <#LETTER: (["a"-"z","A"-"Z"])>
}

int root() :
{}
{
 	exp()
 	{
 	  return 0;
	}
	|
	iff()
	{
 	  return 0;
	}
	|
	forloop()
	{
 	  return 0;
	}
	|
	term()
 	{
 	  return 0;
	}
	| ";"
  	{
    return 1;
  	}
}

void condition() :
{}
{
  < VARIABLE > relops() (< NUMBER >|< VARIABLE >)
}
 
void relops() :
{}
{
  < GREATERTHAN >
| < LESSERTHAN >
| < LESSERTHANEQUAL >
| < GREATERTHANEQUAL >
| < EQUAL  >
| < NOTEQUAL >

}

void comment() :
{}
{
	< OPENCOM > < CLOSECOM >
}


void iff() :
{}
{
	< IF > < OPENPAR > condition() < CLOSEPAR > < THEN > exp() < ELSE > exp() < DELIM >
| 	< IF > < OPENPAR > condition() < CLOSEPAR > < THEN > exp() < DELIM >
}

void exp() :
{}
{
	< VARIABLE > < EQU > term() < DELIM > 	
}
 
void term():
{}
{
  < VARIABLE > ops() < VARIABLE >
| < VARIABLE > ops() term()
| < NUMBER > ops() < VARIABLE >
| < NUMBER > ops() < NUMBER >
| < NUMBER > ops() term()
}

void ops() :
{}
{
	relops()
	|
	mdasops()
	|
	logops()
}


void mdasops() :
{}
{
  <ADD>
| <SUB>
| <MUL>
| <DIV>
| <MOD>
| <EXP>
}

void logops() :
{}
{
	<AND> | <OR> | <NOT>
}
 
void forloop() :
{}
{
	<FOR> <OPENPAR> <VARIABLE> <EQUAL> <NUMBER> <DELIM>
		<VARIABLE> relops() <NUMBER> <DELIM>
		<VARIABLE> <EQUAL> <NUMBER> <CLOSEPAR>
 	| 
	<FOR> <OPENPAR> <VARIABLE> <EQUAL> <VARIABLE> <DELIM>
		<VARIABLE> relops() <VARIABLE> <DELIM>
		<VARIABLE> <EQUAL> <NUMBER> <VARIABLE> <CLOSEPAR>
 	|
 	<FOR> <OPENPAR> <VARIABLE> <EQUAL> <NUMBER> <DELIM>
		<VARIABLE> relops() <NUMBER> <DELIM>
		<VARIABLE> <EQUAL> <VARIABLE> mdasops() <NUMBER> <CLOSEPAR>	 
}